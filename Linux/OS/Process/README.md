# Introduction to processes
درین بخش می خواهیم به پراسس ها و ساختار آنها و همچنین آرایش حافظه درآنها بپردازیم.

توجه داشته باشید که این قسمت خلاصه و کلیتی از فصل 6 کتاب The Linux Programming Interface است.

## | What is a process?
یک پراسس را می توان به طورکلی برنامه ای دانست که درحال اجراست. به عنوان مثال فرض کنید که یک فایل اجراشدنی داریم. منظور از فایل اجراشدنی فایلیست که کامپایل و لینک شده و برای سیستم عامل قابل اجراست. در ویندوز این فایل ها معمولا پسوند exe دارند.

حال اگر این فایل را با دوبار کلیک با از طریق ترمینال اجرا کنیم، یک پراسس ساخته ایم که با تمام شدن برنامه این پراسس از بین می رود. حالا فرض کنید که برنامه حلقه ای دارد که باعث می شود بلافاصله بعد از اجرا تمام نشود یا مثلا بعد از اجرا منتظر ورودی گرفتن از شماست و تمام نمی شود، اگر درین حین دوباره برنامه را با دوبار کلیک یا از طریق ترمینال اجرا کنید، یک پراسس دیگر ساخته اید.

## | Programs vs Processes
شاید بپرسید تفاوت بین یک برنامه و پراسس چیست؟

برنامه یا program به یک فایل که قابلیت اجرا شدن دارد می گویند (به کلمه فایل دقت کنید) اما پراسس ها همانطور که در قسمت قبل گفتیم مثل اشیایی هستند که از یک برنامه ساخته می شوند و توسط سیستم عامل درون رم قرار گرفته، اجرا می شوند.

یک برنامه که یک فایل باینری است موارد زیر را شامل می شود:
1. مشخصات فرمت باینری: هر برنامه ای شامل اطلاعاتی(metainformation) راجع به فرمت یا قالب باینری اش است. کرنل با توجه به این اطلاعات متوجه می شود که چگونه باید برنامه را بخواند. فرمت های باینری قدیمی و رایجی که در یونیکس برای فایل های اجرایی مورد استفاده قرار می گرفتند (و بعضا می گیرند)، خروجی مستقیم
لینکر (a.out)
و بعد از آن فرمت پیشرفته تر 
COFF (Common Object File Format) بودند.
اما امروزه اغلب سیستم های یونیکسی و همینطور لینوکسی از فرمت 
ELF (Executable and Linking Format)
استفاده می کنند.
2. دستورات(instructions) زبان ماشین:
بخشی از برنامه که واقعا توسط سی پی یو به اجرا در می آید.
1. آدرس نقطه شروع به کار برنامه: آدرس اولین دستورالعملی که باید توسط cpu اجرا شود.
2. اطلاعات(data):طلاعاتی که برای مقدار دهی متغیرها و ثوابت استفاده می شوند.(به عنوان مثال استرینگ های که hard coded)
3. جدول های symbols و relocation: جدول های symbol و relocation شامل اسامی متغیرها و توابع می شوند. این جدول ها کاربردهای زیادی دارند. ازجمله دیباگ کردن و run-time symbol resolution (در dynamic linking).
4. اطلاعات shared-library ها و dynamic-linking:
هر برنامه شامل لیستی از shared-library های مورد نیاز برای اجرای برنامه است. همچنین آدرس لینکر پویا (dynamic linker) که برای لود کردن این کتابخانه ها استفاده می شود درون برنامه قرار دارد.
5. اطلاعات دیگر:
برنامه شامل اطلاعات زیاد دیگری است که برای اهداف متفاوتی مورد استفاده قرار می گیرند.
## | How to list Processes?
در لینوکس میتوانیم به روش های مختلفی پراسس ها را لیست کرده و ببینیم. یکی از این روش ها به شکل زیر با اجرای دستور `ps` است.
```bash
$ ps -e
```
فلگ `e-` اینجا برای انتخاب تمام پراسس ها استفاده می شود.

در ویندوز نیز به طریقی مشابه با استفاده از دستور `tasklist` در ترمینال یا `Get-Process` در پاورشل میتوانیم لیست همه پراسس ها را ببینیم.
البته توجه داشته باشید که باید پاورشل یا ترمنیال رو با راست کلیک و انتخاب گزینه `Run as administrator` اجرا کنید.

## | PID and PPID
سیستم عامل وظیفه مدیریت پراسس ها را دارد و برای انجام این وظیفه باید بتواند پراسس ها را از هم تشخیص بدهد. پس به هر پراسس یک Id انتساب میدهد.
این آیدی ها Process id یا PID نامیده می شوند.
PIDها یک عدد صحیح بزرگتر از صفر و منحصر به فرد برای هر پراسس هستند.

در لینوکس هنگامی که سیستم عامل روشن می شود پراسسی با PID مساوی یک به اسم init یا در لینوکس های جدیدتر systemd تولید می شود و این پراسس همه پراسس های لازم برای اجرای سیستم عامل را اجرا می کند (اینکه چگونه یک پراسس، پراسس دیگری را اجرا می کند ، جلوتر توضیح داده می شود).

همچنین هر پراسسی یک پدر یا والد دارد که آنرا اجرا کرده است (به جز چند مورد مانند init)
و این پدر برای خودش یک PID دارد.
پس هر پراسس علاوه بر PID یک PPID (Parent Process ID) دارد که نشان دهنده ی PID ی والدش است و به این ترتیب کل پراسس ها یک درخت تشکیل می دهند.

در لینوکس می توانیم PID و PPID پراسس ها را به روش های مختلفی ببینیم. یکی ازین روش ها استفاده از همان ابزار `ps` است. مانند خط زیر:

```shell
$ ps -e -o comm,pid,ppid
```

جالب اینکه در لینوکس این درخت در نهایت به init یا systemd می رسد. یعنی همه پراسس ها یا توسط خود اینیت به اجرا درآمده اند یا توسط پراسس هایی که اینیت تشکیل داده اجرا شده اند.

البته در سیستم عامل های دیگر مانند ویندوز یا اندروید هم پراسسی شبیه به اینیت در لینوکس وجود دارد. به عنوان مثال در ویندوز پراسسی با اسم wininit را داریم که مانند اینیت لینوکس است.

در لینوکس می توانیم با استفاده از دستور `pstree` درخت پراسس ها را به شکل گرافیکی ببینیم. همچنین از آنجایی که در لینوکس همه چیز فایل هستند، برای هر پراسس یک پوشه(که نوعی فایل است) داریم. به عنوان مثال برای پراسس systemd
در لینوکس های امروزی که PID آن یک است، پوشه
`/proc/1/`
را داریم که شامل اطلاعات کامل پراسس می شود. به طور کلی تر برای هر پراسس یک پوشه به شکل `/proc/PID/` داریم که همه اطلاعات پراسس داخل آن ذخیره می شود.

به عنوان مثال یکی از فایل های جالبی که در این پوشه ها پیدا می شود فایل status است
که شامل PID, PPID, اسم پراسس و اطلاعات خوب دیگری درمورد پراسس مدنظر است.
```bash
$ cat /proc/1/status | head
Name:	systemd
Umask:	0000
State:	S (sleeping)
Tgid:	1
Ngid:	0
Pid:	1
PPid:	0
TracerPid:	0
Uid:	0	0	0	0
Gid:	0	0	0	0
```
## | PID, PPID in C
در زبان سی(در لینوکس) می توانیم PID و PPID پراسسمان(برنامه ای که داریم مینویسم) را
با استفاده از توابع `getpid()`
و `getppid()`
که در هدر `unistd.h`
تعریف شده اند پیدا کنیم.
unistd به شکلی کوتاه شده Unix Standard است.
به مثال زیر توجه کنید:
```c
#include <stdio.h>
#include <unistd.h>

int main(){
    printf("PID: %d\nPPID: %d\n",getpid(),getppid());
    return 0;
}
```
با کامپایل و اجرای برنامه خروجی به شکل زیر است. البته برای هر فرد خروجی متفاوت است:
```bash
$ gcc pid_ppid.c
$ ./a.out
PID: 13139
PPID: 10481
```
## | Orphan Processes
دیدم که تقریبا تمام پراسس ها یک پراسس والد دارند. حال فرض کنید پراسسی که والد پراسس دیگری بوده است از بین برود. مثلا شما با ترمینال vscode را اجرا کرده اید و ترمینال را می بندید. اتفاقی که می افتد این است که یک پراسس بدون والد ایجاد می شود. به این نوع پراسس هایی پراسس یتیم یا orphan گفته می شود.

نکته مهم این است که در لینوکس، با یتیم شدن یک پراسس، پراسس init توسط سیستم عامل به عنوان پراسس والد جایگزین می شود. یعنی پراسس یتیم توسط پراسس init به فرزندی برداشته می شود و از یتیمی خارج می شود!



ادامه دارد ...